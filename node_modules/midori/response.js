"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.installUpgradeResponse = exports.getUpgradeResponse = void 0;

var _httpStatusCodes = require("http-status-codes");

var _httpHeaders = _interopRequireDefault(require("http-headers"));

var _bufferIndexof = _interopRequireDefault(require("buffer-indexof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const endOfHeaders = Buffer.from('\r\n\r\n');

class ProxyUpgradeResponse {
  constructor(socket) {
    _defineProperty(this, "headers", {});

    _defineProperty(this, "statusCode", 200);

    _defineProperty(this, "statusMessage", null);

    _defineProperty(this, "headersSent", false);

    _defineProperty(this, "socket", void 0);

    _defineProperty(this, "finished", false);

    this.socket = socket;
    const oldWrite = socket.write;
    const oldEnd = socket.end;
    let headBuffer = null;

    const restore = () => {
      // $ExpectError
      socket.write = oldWrite; // $ExpectError

      socket.end = oldEnd;
    };

    const wrieHeadBuffer = data => {
      headBuffer = headBuffer ? Buffer.concat([headBuffer, data]) : data;
      const index = (0, _bufferIndexof.default)(headBuffer, endOfHeaders);

      if (index !== -1) {
        headBuffer.slice(0, index);
        Object.assign(this, (0, _httpHeaders.default)(headBuffer));
        this.headersSent = true;
        restore();
      }
    };

    const handleData = (data, encoding) => {
      // $ExpectError
      if (socket.ended || !socket.writable) {
        restore();
        return;
      }

      if (this.headersSent || !data) {
        return;
      }

      if (!Buffer.isBuffer(data)) {
        wrieHeadBuffer(Buffer.from(data, typeof encoding === 'string' ? encoding : undefined));
      } else {
        wrieHeadBuffer(data);
      }
    }; // $ExpectError


    socket.write = (data, encoding, cb) => {
      handleData(data, encoding);
      return oldWrite.call(socket, data, encoding, cb);
    }; // $ExpectError


    socket.end = (data, encoding, cb) => {
      handleData(data, encoding);
      return oldEnd.call(socket, data, encoding, cb);
    };
  }

  getHeader(name) {
    return this.headers[name.toLowerCase()];
  }

  writeHead(statusCode = this.statusCode, msg, headers) {
    if (this.headersSent) {
      return;
    }

    this.statusCode = statusCode;

    if (typeof msg === 'string') {
      this.statusMessage = msg;
    } else {
      try {
        this.statusMessage = (0, _httpStatusCodes.getStatusText)(this.statusCode);
      } catch (err) {
        this.statusMessage = '';
      }
    }

    let newHeaders = {};

    if (typeof headers === 'undefined' && typeof msg === 'object') {
      newHeaders = msg;
    } else if (typeof headers === 'object') {
      newHeaders = headers;
    }

    Object.keys(newHeaders).forEach(k => {
      this.headers[k.toLowerCase()] = newHeaders[k];
    });
    this.headersSent = true;
    this.socket.write(`HTTP/1.1 ${this.statusCode}`);

    if (typeof this.statusMessage === 'string' && this.statusMessage.length > 0) {
      this.socket.write(` ${this.statusMessage}\n`);
    } else {
      this.socket.write('\n');
    }

    Object.keys(this.headers).forEach(header => {
      const value = this.headers[header];

      if (typeof value === 'string') {
        this.socket.write(`${header}: ${value}\n`);
      } else if (Array.isArray(value)) {
        value.forEach(value => {
          this.socket.write(`${header}: ${value}\n`);
        });
      }
    });
    this.socket.write('\n');
  }

  removeHeader(n) {
    delete this.headers[n.toLowerCase()];
  }

  setHeader(n, v) {
    this.headers[n.toLowerCase()] = v;
  }

  removeListener(...args) {
    this.socket.removeListener(...args);
  }

  on(...args) {
    this.socket.on(...args);
    return this;
  }

  once(...args) {
    this.socket.once(...args);
    return this;
  }

  emit(...args) {
    this.socket.emit(...args);
    return this;
  }

  write(...args) {
    if (!this.headersSent) {
      this.writeHead();
    }

    return this.socket.write(...args);
  }

  end(...args) {
    this.finished = true;

    if (!this.headersSent) {
      this.writeHead();
    }

    return this.socket.end(...args);
  }

}

const proxyResponseCache = new WeakMap();

const getUpgradeResponse = req => {
  return proxyResponseCache.get(req);
};

exports.getUpgradeResponse = getUpgradeResponse;

const installUpgradeResponse = (req, socket) => {
  let proxyResponse = proxyResponseCache.get(req);

  if (proxyResponse === undefined) {
    proxyResponse = new ProxyUpgradeResponse(socket);
    proxyResponseCache.set(req, proxyResponse);
  }

  return proxyResponse;
};
/**
 * Main thing.
 * @param {Function} handler Request handler. Must return another app.
 * @returns {App} App instance.
 */


exports.installUpgradeResponse = installUpgradeResponse;

const response = handler => app => {
  return _objectSpread({}, app, {
    request: async (req, res) => {
      try {
        const nextApp = await handler(res);
        return await nextApp(app).request(req, res);
      } catch (err) {
        return await app.requestError(err, req, res);
      }
    },
    upgrade: async (req, socket, head) => {
      try {
        const proxyResponse = installUpgradeResponse(req, socket); // flowlint-next-line unclear-type: off

        const nextApp = await handler(proxyResponse);
        return await nextApp(app).upgrade(req, socket, head);
      } catch (err) {
        return await app.upgradeError(err, req, socket, head);
      }
    }
  });
};

response._selector = () => null;

var _default = response;
exports.default = _default;
//# sourceMappingURL=response.js.map