{"version":3,"sources":["../src/body.js"],"names":["contentstream","req","inflate","encoding","headers","toLowerCase","stream","type","zlib","createInflate","pipe","createGunzip","isParsed","WeakMap","withOptions","options","request","has","bodyOptions","limit","charset","get","length","set","body"],"mappings":";;;;;;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;AAKA,MAAMA,aAAa,GAAG,CAACC,GAAD,EAAuBC,OAAvB,KAAuD;AAC3E,QAAMC,QAAQ,GAAG,CACfF,GAAG,CAACG,OAAJ,CAAY,kBAAZ,KAAmC,UADpB,EAEfC,WAFe,EAAjB;AAGA,MAAIC,MAAJ;;AAEA,MAAIJ,OAAO,KAAK,KAAZ,IAAqBC,QAAQ,KAAK,UAAtC,EAAkD;AAChD,UAAM,yBAAY,GAAZ,EAAkB,iCAAgCA,QAAS,GAA3D,EAA+D;AACnEA,MAAAA,QAAQ,EAAEA,QADyD;AAEnEI,MAAAA,IAAI,EAAE;AAF6D,KAA/D,CAAN;AAID;;AAED,UAAQJ,QAAR;AACE,SAAK,SAAL;AACEG,MAAAA,MAAM,GAAGE,cAAKC,aAAL,EAAT;AACAR,MAAAA,GAAG,CAACS,IAAJ,CAASJ,MAAT;AACA;;AACF,SAAK,MAAL;AACEA,MAAAA,MAAM,GAAGE,cAAKG,YAAL,EAAT;AACAV,MAAAA,GAAG,CAACS,IAAJ,CAASJ,MAAT;AACA;;AACF,SAAK,UAAL;AACEA,MAAAA,MAAM,GAAGL,GAAT;AACA;;AACF;AACE,YAAM,yBAAY,GAAZ,EAAkB,iCAAgCE,QAAS,GAA3D,EAA+D;AACnEA,QAAAA,QAAQ,EAAEA,QADyD;AAEnEI,QAAAA,IAAI,EAAE;AAF6D,OAA/D,CAAN;AAbJ;;AAmBA,SAAOD,MAAP;AACD,CAjCD;;AA0CA,MAAMM,QAA2C,GAAG,IAAIC,OAAJ,EAApD;;AAEO,MAAMC,WAAW,GAAG,CAACC,OAAgB,GAAG,EAApB,KACzB,6BACEC,gBADF,EAEE,MAAOf,GAAP,IAAoD;AAClD,MAAIW,QAAQ,CAACK,GAAT,CAAahB,GAAb,CAAJ,EAAuB;AACrB,UAAM,yBAAY,GAAZ,EAAiB,oBAAjB,CAAN;AACD;;AACD,QAAMiB,WAAW,GAAG;AAClBf,IAAAA,QAAQ,EAAEY,OAAO,CAACZ,QADA;AAElBgB,IAAAA,KAAK,EAAEJ,OAAO,CAACI;AAFG,GAApB;AAIA,QAAMZ,IAAI,GAAG,gCAAiBN,GAAG,CAACG,OAAJ,CAAY,cAAZ,CAAjB,CAAb;AACA,QAAMgB,OAAO,GAAGb,IAAI,IAAIA,IAAI,CAACc,GAAL,CAAS,SAAT,CAAxB;;AACA,MACE,OAAOD,OAAP,KAAmB,QAAnB,IACAA,OAAO,CAACE,MAAR,GAAiB,CADjB,IAEA,OAAOP,OAAO,CAACZ,QAAf,KAA4B,WAH9B,EAIE;AACAe,IAAAA,WAAW,CAACf,QAAZ,GAAuBiB,OAAvB;AACD;;AACD,QAAMd,MAAM,GAAGN,aAAa,CAACC,GAAD,EAAMc,OAAO,CAACb,OAAd,CAA5B;AACAU,EAAAA,QAAQ,CAACW,GAAT,CAAatB,GAAb,EAAkB,IAAlB;;AACA,MAAIc,OAAO,CAACT,MAAR,KAAmB,IAAvB,EAA6B;AAC3B,WAAOA,MAAP;AACD;;AACD,SAAO,MAAM,sBAAQA,MAAR,EAAgBY,WAAhB,CAAb;AACD,CAzBH,CADK;AA6BP;;;;;;;AAIA,MAAMM,IAAI,GAAGV,WAAW,EAAxB;AACAU,IAAI,CAACV,WAAL,GAAmBA,WAAnB;eAEeU,I","sourcesContent":["// @flow\nimport createError from 'http-errors';\nimport getBody from 'raw-body';\nimport zlib from 'zlib';\nimport parseContentType from 'content-type-parser';\n\nimport createSelector from './createSelector';\nimport request from './request';\n\nimport type {IncomingMessage} from 'http';\nimport type {Readable} from 'stream';\n\nconst contentstream = (req: IncomingMessage, inflate?: boolean): Readable => {\n  const encoding = (\n    req.headers['content-encoding'] || 'identity'\n  ).toLowerCase();\n  let stream;\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, `unsupported content encoding \"${encoding}\"`, {\n      encoding: encoding,\n      type: 'encoding.unsupported',\n    });\n  }\n\n  switch (encoding) {\n    case 'deflate':\n      stream = zlib.createInflate();\n      req.pipe(stream);\n      break;\n    case 'gzip':\n      stream = zlib.createGunzip();\n      req.pipe(stream);\n      break;\n    case 'identity':\n      stream = req;\n      break;\n    default:\n      throw createError(415, `unsupported content encoding \"${encoding}\"`, {\n        encoding: encoding,\n        type: 'encoding.unsupported',\n      });\n  }\n\n  return stream;\n};\n\ntype Options = {\n  encoding?: string,\n  inflate?: boolean,\n  limit?: number,\n  stream?: boolean,\n};\n\nconst isParsed: WeakMap<IncomingMessage, boolean> = new WeakMap();\n\nexport const withOptions = (options: Options = {}) =>\n  createSelector(\n    request,\n    async (req): Promise<string | Buffer | Readable> => {\n      if (isParsed.has(req)) {\n        throw createError(500, 'Body already read.');\n      }\n      const bodyOptions = {\n        encoding: options.encoding,\n        limit: options.limit,\n      };\n      const type = parseContentType(req.headers['content-type']);\n      const charset = type && type.get('charset');\n      if (\n        typeof charset === 'string' &&\n        charset.length > 0 &&\n        typeof options.encoding === 'undefined'\n      ) {\n        bodyOptions.encoding = charset;\n      }\n      const stream = contentstream(req, options.inflate);\n      isParsed.set(req, true);\n      if (options.stream === true) {\n        return stream;\n      }\n      return await getBody(stream, bodyOptions);\n    },\n  );\n\n/**\n * @tag http\n * @desc Do the thing.\n */\nconst body = withOptions();\nbody.withOptions = withOptions;\n\nexport default body;\n"],"file":"body.js"}