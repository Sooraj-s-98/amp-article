"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compose = _interopRequireDefault(require("./compose"));

var _request = _interopRequireDefault(require("./request"));

var _status = _interopRequireDefault(require("./status"));

var _send = _interopRequireDefault(require("./send"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultOnTimeout = (0, _compose.default)((0, _status.default)(500), (0, _send.default)('Timeout.'));
const defaultOptions = {
  timeout: 10000,
  onTimeout: defaultOnTimeout
};
/**
 * Pending allows you to wait for a given trigger before continuing the
 * request chain. If this condition is not met within the given timeout then
 * the `onTimeout` app is used instead. If the condition is met then the
 * current app can be replaced.
 * @param {Function} trigger Function invoked during the request which is
 * passed a trigger callback. You call this trigger callback whenever you
 * are ready to continue the request.
 * @param {Object} options Options to control pending behaviour.
 * @param {Number} options.timeout How long to wait before timing out.
 * @param {Object} options.onTimeout App to use when timeout occurs.
 * @returns {App} App instance.
 */

const pending = (trigger, options = defaultOptions) => {
  const {
    timeout = defaultOptions.timeout,
    onTimeout = defaultOptions.onTimeout
  } = options;
  return (0, _request.default)(req => new Promise(resolve => {
    let disposer = null;

    const dispose = () => {
      if (disposer) {
        disposer();
        disposer = null;
      }
    };

    const timer = setTimeout(() => {
      dispose();
      resolve(onTimeout);
    }, timeout);

    const fn = newApp => {
      clearTimeout(timer);
      dispose();
      resolve(newApp);
    };

    disposer = trigger(fn);
    req.on('close', dispose);
  }));
};

var _default = pending;
exports.default = _default;
//# sourceMappingURL=pending.js.map