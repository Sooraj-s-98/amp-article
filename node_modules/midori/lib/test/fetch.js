"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createMockRequest = _interopRequireDefault(require("./createMockRequest"));

var _createMockResponse = _interopRequireDefault(require("./createMockResponse"));

var _response = require("../response");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fetch = async (App, url, _options) => {
  let globalError = null;
  const options = _options || {};
  const stub = {
    request: () => {
      options.onNext && options.onNext();
    },
    requestError: err => {
      globalError = err;
      options.onError && options.onError(err);
    },
    upgradeError: err => {
      globalError = err;
      options.onError && options.onError(err);
    },
    // TODO: Do we need to check for errors here?
    error:
    /* istanbul ignore next */
    () => {},
    close: () => {},
    upgrade: () => {
      options.onNext && options.onNext();
    },
    listening: () => {}
  };

  if (typeof App !== 'function') {
    throw new TypeError('Must pass valid app to `fetch`.');
  }

  const app = App(stub);
  let req = (0, _createMockRequest.default)({
    url,
    method: options.method,
    headers: options.headers,
    body: options.body,
    encrypted: options.encrypted,
    offline: options.offline
  });
  const res = (0, _createMockResponse.default)();

  if (options.mapRequest) {
    // $ExpectError
    req = options.mapRequest(req);
  } // TODO: FIXME: Any better way of casting through `any`?
  // flowlint-next-line unclear-type: off


  const realRes = res;
  let result;

  if (typeof req.headers.connection === 'string' && req.headers.connection.toLowerCase() === 'upgrade') {
    // flowlint-next-line unclear-type: off
    result = await app.upgrade(req, res.socket, new Buffer(''));
  } else {
    // flowlint-next-line unclear-type: off
    result = await app.request(req, realRes);
  } // flowlint-next-line unclear-type: off


  const mock = (0, _response.getUpgradeResponse)(req);

  if (mock) {
    res.headers = mock.headers;
    res.statusCode = mock.statusCode;
    res.statusMessage = mock.statusMessage;
    res.headersSent = mock.headersSent;
    res.finished = mock.finished;
  }

  if (globalError && !options.onError) {
    return Promise.reject(globalError);
  }

  realRes.error = globalError;
  realRes.result = result;

  if (res.bodyActive) {
    // FIXME: flow being stupid again
    // $ExpectError
    realRes.body = await res.body;
    return realRes;
  }

  return realRes;
};

var _default = fetch;
exports.default = _default;
//# sourceMappingURL=fetch.js.map